
'''
Okay I'm gonna start with these 2:

Acetyl Transferase - 3S6F - Coenzyme A (COA)
des:
78, 79, 80, 85, 86, 87, 88, 90,
91, 114, 115, 118, 119, 121
(n = 14)
pack:
4, 6, 26, 27, 28, 52, 60, 62, 63, 75, 77,
81, 84, 89, 93, 94, 95, 109, 111, 112,
116, 117, 122, 124, 126, ligand (n =
26)

Amino-transferase - 2XBN - 4'-deoxy-4'-aminopyridoxal-5'-phosphate (PMP)
des:
73, 133, 134, 135, 138, 159,
161, 202, 231, 233, 234, 262,
264, 265 (n = 14)
pack:
75, 136, 137, 139, 141, 142, 155, 158,
162, 164, 200, 204, 205, 206, 236,
260, 270, 273, 347, 349, 390, 392,
ligand (n = 23)

------------------------------------------------
loading complex for 2xbn (3s6f already did it):
downloaded sdf file for pmp from rcsb.org
added hydrogens to pmp in avogadro
rosetta/main/source/scripts/python/public/molfile_to_params.py -n hem -p hem —conformers-in-one-file hem.mol2
cleanATOM(2xbn.pdb)
load clean ptn + lig.pdb in pymol and save complex
sed -e "s/HETATM/ATOM  /g" 2xbn_complex_het.pdb > 2xbn_complex.pdb


1. ligand mdl file
2. add hydrogens in avogadro
3. mdl to params script
cpu/rosetta/main/source/scripts/python/public/molfile_to_params.py -n coa -p coa coa.sdf
4. clean ptn pdb and remove ligand
5. load clean ptn, ligand pdb into pymol, export complex pdb (orientation and coords should automatically be right)
6. clean complex pdb:
all atom lines, no hetatm (sed -e "s/HETATM/ATOM__/g" 3s6f_complex.pdb > cleancomplex.pdb
ligand chain should be X
ligand after protein chains
7. load into pyrosetta

p = Pose()
l = ['pmp.params']
generate_nonstandard_residue_set(p,l)
pose_from_file(p, '2xbn_complex.pdb')
------------------------------------------------
need resfile, des positions are ALLAA, pack positions are NATAA, others are NATRO, ex1 ex2,
extra chi cutoff 0 , contrain relax to start coords, cst std dev 0.5

ALLAA           # allow all amino acids
EX 1 EX 2       # allow extra chi rotamers at chi-id 1 and 2 (note: multiple commands can be on the same line.)
USE_INPUT_SC    # allow the use of the input side chain conformation   ( see below for more detailed description of commands)
start
<PDBNUM>[<ICODE>] <CHAIN>  <COMMANDS> 	#<PDBNUM>[<ICODE>] corresponds to columns 22-26
40A Q ALLAA   # Residue 40, insertion code A, on chain Q, use any residue type

so I need a script that can take input pdb + text file specifying certain res, output the desired resfile
will make and call resfile.py
------------------------------------------------

rel = pyrosetta.rosetta.protocols.relax.FastRelax()
tf = pyrosetta.rosetta.core.pack.task.TaskFactory()
read = pyrosetta.rosetta.core.pack.task.operation.ReadResfile('2xbn.resfile')
tf.push_back(read)
rel.set_task_factory(tf)

sf = get_fa_scorefxn()
rel.set_scorefxn(sf)

mm = MoveMap()
mm.set_bb(True)
mm.set_chi(True)
rel.set_movemap(mm)

rel.apply(p)

#This works, and I'm curious to check if it is doing what I want, and to figure out
#how to add the harmonic coordinate constraints, ex1, extra chi 0, but for now I am
#gonna move on to trying with command line rosetta

echi = pyrosetta.rosetta.core.pack.task.operation.ExtraChiCutoff(0.0)
tf.push_back(echi)
ex1 = pyrosetta.rosetta.core.pack.task.operation.ExtraRotamersGeneric().ex1(True)
ex2 = pyrosetta.rosetta.core.pack.task.operation.ExtraRotamersGeneric().ex2(True)
tf.push_back(ex1)
tf.push_back(ex2)
rel.constrain_relax_to_start_coords(constrain_relax_to_start_coords=True)
coord_cst_stdev .5
------------------------------------------------
~/desktop/Rosetta/main/source/bin/score_jd2.macosclangrelease -in:file:s 2xbn_complex.pdb -ignore_unrecognized_res
time ~/desktop/Rosetta/main/source/bin/relax.default.macosclangrelease -s 2xbn_complex.pdb -resfile 2xbn.resfile -extra_res_fa pmp.params -ex1 -ex2 -extrachi_cutoff 0 -nstruct 3 -in:file:fullatom -relax:fast -relax:respect_resfile -relax:constrain_relax_to_start_coords -relax:coord_cst_stdev .5
------------------------------------------------
<ROSETTASCRIPTS> ~/desktop/Rosetta/main/source/bin/rosetta_scripts.default.macosclangrelease -l pdblist.txt -extra_res_fa pmp.params -parser:protocol iam.xml -parser:view -out:file:score_only iam-score.sc
    <SCOREFXNS>
			<ScoreFunction name="sf" weights="ref2015">
			</ScoreFunction>
    </SCOREFXNS>
    <RESIDUE_SELECTORS>
    </RESIDUE_SELECTORS>
    <TASKOPERATIONS>
    </TASKOPERATIONS>
    <FILTERS>
    </FILTERS>
    <MOVERS>
			<InterfaceAnalyzerMover name="iam" scorefxn="sf" packstat="True" interface_sc="True" />
    </MOVERS>
    <PROTOCOLS>
			<Add mover_name="iam"/>
    </PROTOCOLS>
    <OUTPUT />
</ROSETTASCRIPTS>
------------------------------------------------
Natural sequences of these binding sites were obtained using the protein family
 alignment from Pfam and filtered to remove all redundant sequences.


 Once the
multiple alignment is de®ned, the pro®le is constructed by counting the numbers of each amino
acid at each position along the multiple alignment.
These counts are transformed into probabilities by
normalizing the counts by the total number of
amino acids and gaps observed at that position.
These empirical probabilities re¯ect the likelihood
of observing any amino acid k at position i. Since
the counts are based on a ®nite set of sequences it
can happen that not all 20 amino acids are
observed at each position. Therefore, pseudo
counts are introduced so that no amino acid has a
zero probability to occur at position i. For more
information on pro®le generating techniques, see
Gribskov & Veretnik.26

1. get the sequences
2. function to turn sequences into probability distributions
3. function to calculate js divergence for each position in 2 profiles
pps = 1-js
is it just for positions that are designable? or does it not matter since those
only differences, so doing for whole thing captures anyway

pseudo counts you can just add one to every event
need to add to this code, change lists to counts and start at 1
then string together into script that takes 2 alignment fastas and returns pps
for each position
then im gonna need a way to generate seq alignments from list of pdb files
output by filter script. at that point i have
everything but the actual strc and native sequences to run
score->filter->subset_alignments->pps_subset/natural_binding_pos

actual strc
native sequences
position of binding site residues in native alignment
position of bionding site residues in designs alignment
'''
'''
------------------------------------------------

import Bio as bio
from Bio.Align.Applications import MafftCommandline
>>> from Bio.Align.Applications import MafftCommandline
>>> mafft_exe = "/opt/local/mafft"
>>> in_file = "../Doc/examples/opuntia.fasta"
>>> mafft_cline = MafftCommandline(mafft_exe, input=in_file)
>>> print(mafft_cline)
/opt/local/mafft ../Doc/examples/opuntia.fasta

If the mafft binary is on the path (typically the case on a Unix style operating system) then you don't need to supply the executable location:

>>> from Bio.Align.Applications import MafftCommandline
>>> in_file = "../Doc/examples/opuntia.fasta"
>>> mafft_cline = MafftCommandline(input=in_file)
>>> print(mafft_cline)
mafft ../Doc/examples/opuntia.fasta

You would typically run the command line with mafft_cline() or via the Python subprocess module, as described in the Biopython tutorial.

Note that MAFFT will write the alignment to stdout, which you may want to save to a file and then parse, e.g.:

stdout, stderr = mafft_cline()
with open("aligned.fasta", "w") as handle:
    handle.write(stdout)
from Bio import AlignIO
align = AlignIO.read("aligned.fasta", "fasta")

from Bio import SeqIO as seqio
for record in seqio.parse('2xbn_complex.pdb','pdb-atom'):
  s=record.seq
-------------------------------------------------
perhaps I can align every sequence from the family to des starting strc sequence,
numbering of bs res in that strc will align with bs res in others hopefully?
-------------------------------------------------
COUPLED MOVES TRIAL with 2xbn


~/desktop/Rosetta/main/source/bin/coupled_moves.default.macosclangrelease -s 2xbn_complex.pdb -mute protocols.backrub.BackrubMover -ex1 -ex2 -extrachi_cutoff 0 -nstruct 1 -ignore_unrecognized_res -score::weights ref2015 -extra_res_fa pmp.params -resfile 2xbn.resfile -coupled_moves::mc_kt 2.4 -coupled_moves::boltzmann_kt 2.4 -coupled_moves::ntrials 1000 -coupled_moves::initial_repack false -coupled_moves::ligand_mode true -coupled_moves::ligand_weight 2 -coupled_moves::fix_backbone false -coupled_moves::bias_sampling true -coupled_moves::bump_check true -coupled_moves::exclude_nonclashing_positions true -coupled_moves::backbone_mover kic -coupled_moves::kic_perturber walking -nstruct 1
-------------------------------------------------
DR KORTEMME MEETING OCT 24

rotation:
  -correlation for score terms
  -ranktop dist in addition to pps
  -cody:pareto front:how to best filter ptns from multiple terms
  -OG plan good:
    -add more filters
    -plots for FD, BR designs
    -qualitatively id terms that appear to correlate with PPS consistently

ancestral reconstruction
fleishman algorithm for stability
  -do the stable proteins from these have more charges even though its not
  explicitly the goal?

NEXT MEETING THURSDAY AFTER RETREAT 1:30

-------------------------------------------------


fig,ax=plt.subplots()
bp_dict = ax.boxplot(pltdatas)
ax.set_title('feat')
ax.set_ylabel('PPS')
xlocs=[x+1 for x in range(len(pltdatas))]
xlabs=['1','1.4','1.5']
plt.xticks(xlocs, xlabs)
plt.text(0.2,0.1,'test text',transform=ax.transAxes)
nstrcs=['100','200','50']
ax.legend(nstrcs)
bp_dict = ax.boxplot(pltdatas)
for line in bp_dict['medians']:
    x,y = line.get_xydata()[1]
    plt.text(x,y, '%.3f' % y,verticalalignment='center')
for i, line in enumerate(bp_dict['boxes']):
    x, y = line.get_xydata()[0] # bottom of left line
    plt.text(x,y, nstrcs[i],
         horizontalalignment='center', # centered
         verticalalignment='top')
plt.show()
plt.clf()

-------------------------------------------------

CORRELATION COEFFICIENTS OF SCORETERMS

have pandas dataframe with columns as each score term, rows as each protein

import pandas as pd
df = pd.read_fwf('all_scores.sc') #after deleting first line SEQUENCE
df.corr() #row variable correlation with the column variable is the value of the cell
corr_cos = df.corr()
pd.DataFrame(corr_cos).to_csv("correlations.csv") #print to csv file

-------------------------------------------------

RANKTOP DEVELOPMENT

residues at binding site positions ranked by frequency
rank in predicted profile of top ranked residue from known profile
if doesnt appear rank=20


-------------------------------------------------

HAVING TROUBLE USING HOLES BECAUSE DALPHABALL EXE WONT COMPILE

DAlpahBall [student] $ make
gcc -c -O3 -I/usr/local/include DAlphaBall.c
gcc -c -O3 -I/usr/local/include sos_minor_gmp.c
gcc -c -O3 -I/usr/local/include alf_tools_gmp.c
gcc -c -O3 -I/usr/local/include binding.c
binding.c:349:2: warning: implicit declaration of function 'cavballs_' is
      invalid in C99 [-Wimplicit-function-declaration]
        cavballs_( x, y, z, r, &ncav );
        ^
1 warning generated.
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore adjust.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore alfcx.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore alfcx_tools.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore cavballs.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore delcx.f
delcx.f:4288:72:

 4288 |   pause
      |
Warning: Deleted feature: PAUSE statement at (1)
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore truncate_real.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore measure_tools.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore surface_tools.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore surface_only.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore surface_deriv_coord.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore volume_tools.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore volume_only.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore volume_deriv_coord.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore vector.f
gfortran -c -O3 -x f77-cpp-input -fsecond-underscore write_simplices.f
gcc -o ./DAlphaBall.gcc -O3 DAlphaBall.o sos_minor_gmp.o alf_tools_gmp.o binding.o adjust.o alfcx.o alfcx_tools.o cavballs.o delcx.o truncate_real.o measure_tools.o surface_tools.o surface_only.o surface_deriv_coord.o volume_tools.o volume_only.o volume_deriv_coord.o vector.o write_simplices.o -L/usr/local/lib -lgmp  -lm -lgfortran
ld: library not found for -lgfortran
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [DAlphaBall.gcc] Error 1

-------------------------------------------------
NEED A SCRIPT TO TAKE ACT ON DIRECTORY OF SCOREFILES
AND MERGE ALL INTO ONE GIANT SCOREFILE
THAT I CAN THEN GET THE CORRELATION COEFFICIENTS
IDEALLY THE STRUCTURE NAMES WOULD BE EDITED SO THAT THEY ARE DIFFERENT
FOR THE DIFFERENT METHODS
HOWEVER FOR THE PURPOSE OF GETTING THESE CORRELATIONS IT DOESNT MATTER
--------------------------------------------------
what is the combination of filter terms and weights that, when applied to
a set of designed structures, produces a subset with maximized pps

first is, what are the relevant filter terms to use?
second is, how to combine them and select threshold values?

I have identified some relevant filter terms, but I have not QUANTIFIED THEIR
RELEVANCE
A straightforward way to combine is to take the top quintile structures for
every relevant term (if less than a certain number of strc, include more to
meet the minimum) and look for the structures with the greatest number of
occurrences amongst the whole set, ie those that are in the top quintile for
the greatest number of terms. WHAT WOULD BE THE PPS OF THESE STRC, AND HOW
WOULD IT COMPARE TO THE PPS OF THE TOP QUINTILE FOR INDIVIDUAL FILTERS, ALONE?

alternatively, could i somehow ask what is the subset of structures with the
highest pps value, and then look at their features?


I THINK THE BEST NEXT STEP IS TO JUST COMPLETE THE IDENTIFICATION OF TERMS
IN THE SAME QUALITATIVE WAY THAT IVE BEEN DOING, CHECK OUT THEIR CORRELATIONS
WITH EACH OTHER, AND GET A FINAL LIST OF TERMS TO DO THE COMBINATION ANALYSIS
WITH. IE, GET STRC IN TOP QUINTILE OF EACH AND DO SOME ANALYSIS OF RESULTING
SETS. what is pps of strc in multiple top quintiles? are there a lot? which groups
of terms tend to have strc in each?

KEEP IN MIND THAT TERMS THAT ARE EFFECTIVE EVEN WHEN TOTAL SCORE IS NOT
ARE PROBABLY MORE USEFUL

-----------------------------------------------------
okay, analyze all metric pps plots and id terms, look at all their correlations,
get final set of terms to explore further with multi filter script

better ways (ie any way) to actually quantify the power of the terms would be
great

very interested in algorithm to find highest pps subset amongst structures
in top quintile of at least one relevant metric

-----------------------------------------------------
I THINK 3DLC MIGHT NOT BE WORKING BECAUSE SAM LINES IN PDB ARE HET INSTEAD OF ATOM

sed -e "s/HETATM/ATOM  /g" 3DLC_0001.pdb > cleanpdbs/3DLC_0001.pdb

make a folder called cleanpdbs

import os
f = open('pdblist.txt','r')
names=[line.strip('\n') for line in f.readlines()]
for filename in names:
  s='sed -e "s/HETATM/ATOM  /g" '+filename+' > '+'cleanpdbs/'+filename
  os.system(s)

OKAY NOW MAYBE 3S6F WASNT WORKING FOR THE SAME REASON, LETS TRY THE SAME THING

ALRIGHT NOW FOR 2IJ2 I NEED TO GENERATE THE PARAMS FILE AND THEN CLEAN THE PDBS
ugh i think its gonna be easier to do this on my other laptop cus i can use
avogadro to add H and python 2 is default lol

OKAY FOR ALL OF THESE NEW CLEANPDBS DIRECTORIES I NEED TO MAKE SURE PDBLIST, params,
ARE THERE SO I CAN GENERATE SCOREFILES, THEN RUN PPS

GOD DAMN, ITS STILL NOT WORKING, WILL NOW TRY TO DELETE ALL NON ATOM LINES

FFS IM STILL GETTING ONE OF TWO ERRORS:
EITHER IT DOESNT RECOGNIZE SECOND CHAIN SO IAM FAILS BUT OTHER works
ERROR: InterfaceAnalyzerMover: pose has only one chain, aborting analysis

OR IT SAYS IT CANT FIND LIGAND AND NOTHING WORKS
File: src/core/io/pose_from_sfr/PoseFromSFRBuilder.cc:512
[ ERROR ] UtilityExitException
ERROR: No match found for unrecognized residue at position 220( PDB ID:    1 X )
Looking for lower-terminal upper-terminal residue with 3-letter code: SAM
This can be caused by wrong residue naming. E.g. a BMA (beta-mannose) is named MAN (alpha-mannose)

-----------------------------------------------------

MUTATION PROFILES
take starting strc that designs were generated off
for each position, look at all the mutations (ala to glu; ala to ile; etc.)
generate matrix where y is all residues for native protein,
x is all residue for design proteins
entries are number of times a y->x mutation occurred (5 ala to glus? 10 ala to ile?)
get a mutation profile for each structure, sum for all strc for each method
compare with mutation profile of native -> all other natives
1. mut profiles for each strc native->des
2. ^ native->all natives
3. sum each for all strc to give des profiles for each method to compare with nat
(nat profile same for all methods for a given strc), summed profile only 1
4. y all amino acids
  x native, fd, cm, bre
  values are number of mutations to that residue
^^^^can do one of these for each structure, at the least, which should def be valid
^^^^can maybe do another summed over all strc, even though kinda sketch

-----------------------------------------------------
okay i already did the fucking script so

1.run freq table on all strc
master table for all as well

2. top 50 analysis
for each strc,
all, 50, 25, top metric + its name
does top50 outperform bulk? does it outperform best metric?

5. 25 data points analysis to get pearson r between normalized score value and
mean pps of subsets with better score than that value for 14 relevant terms,
looking across all strc
if its interesting do it for some other terms as well
INSTEAD I DID PERCD AS A WAY TO TRY TO QUANTIFY

4. apply new fast design

6. pareto frontier

7. mutation profiles

3. a very simple way to quantify usefulness of different terms might be the %difference
between the max pps of subset for that term and max pps of total score subset
i could get such a value for each structure
then look at mean and variance amongst that set of values

ranktop of term top pps vals!!!!! or just rank

-----------------------------------------------------
so for each term, i want a list of 3 lists (1 for each method), where each list
is the %diff vals for the max pps subset of that term and the max for TS

in addition, for each strc +method i want a list with all the terms ranked by
descending max pps

-----------------------------------------------------

REPEAT TIOP50 ANALYSIS WITH THE TERMS THAT HAVE BEST PERCD OVER TOTAL SCORE
(IE TOP TERMS FROM FA2 ANALYSIS)

MUTATION PROF

NEW FAST DESIGN

PARETO FRONT ANALYSIS

TRY EVERYTHING ON OTHER STRC
-----------------------------------------------------

for every strc from every method, there is at least one filter that outperforms
total score, that does exceptionally well. suggests there are better ways to filter
than others, but i guess that is kind of obvious. the real question is, what are the
best ways to filter for a given set of designs?

'ideal' terms may correlate with more detailed properties of structures or
ligands, is there some way to analyze this? ie what if a ligand is charged,
what if it is relatively big, what kinds of chemistry does it do in the binding site?
do these properties influence which terms end up being more effective at distinguishing
high pps subsets of strc? i already know that it varies across methods, but does it
vary in this way also?

-----------------------------------------------------
analyze pareto while run top50 round 2--------------------
freq bar graphs --------------------
pareto graph? 
mutation profs
prepare presentation

new fast design

other strc

work on estat paper

-----------------------------------------------------

df2=df.drop(columns=['Unnamed: 7','Unnamed: 8','Unnamed: 9'])

In [60]: tf=[i for i in df2['top50']]

In [61]: par=[i for i in df2['pareto']]

In [62]: np.mean(tf)
Out[62]: 788.3333333333334

In [63]: np.mean(par)
Out[63]: 769.8666666666667

In [64]: tm=[i for i in df2['top-metric_value']]

In [65]: np.mean(tm)
Out[65]: 819.9333333333333

In [66]: ts=[i for i in df2['total-score']]

In [67]: np.mean(ts)
Out[67]: 758.0666666666667
