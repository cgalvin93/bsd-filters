
'''
Okay I'm gonna start with these 2:

Acetyl Transferase - 3S6F - Coenzyme A (COA)
des:
78, 79, 80, 85, 86, 87, 88, 90,
91, 114, 115, 118, 119, 121
(n = 14)
pack:
4, 6, 26, 27, 28, 52, 60, 62, 63, 75, 77,
81, 84, 89, 93, 94, 95, 109, 111, 112,
116, 117, 122, 124, 126, ligand (n =
26)

Amino-transferase - 2XBN - 4'-deoxy-4'-aminopyridoxal-5'-phosphate (PMP)
des:
73, 133, 134, 135, 138, 159,
161, 202, 231, 233, 234, 262,
264, 265 (n = 14)
pack:
75, 136, 137, 139, 141, 142, 155, 158,
162, 164, 200, 204, 205, 206, 236,
260, 270, 273, 347, 349, 390, 392,
ligand (n = 23)

------------------------------------------------
loading complex for 2xbn (3s6f already did it):
downloaded sdf file for pmp from rcsb.org
added hydrogens to pmp in avogadro
cpu/rosetta/main/source/scripts/python/public/molfile_to_params.py -n pmp -p pmp —conformers-in-one-file pmp.sdf
cleanATOM(2xbn.pdb)
load clean ptn + lig.pdb in pymol and save complex
sed -e "s/HETATM/ATOM  /g" 2xbn_complex_het.pdb > 2xbn_complex.pdb
------------------------------------------------
p = Pose()
l = ['pmp.params']
generate_nonstandard_residue_set(p,l)
pose_from_file(p, '2xbn_complex.pdb')
------------------------------------------------
need resfile, des positions are ALLAA, pack positions are NATAA, others are NATRO, ex1 ex2,
extra chi cutoff 0 , contrain relax to start coords, cst std dev 0.5

ALLAA           # allow all amino acids
EX 1 EX 2       # allow extra chi rotamers at chi-id 1 and 2 (note: multiple commands can be on the same line.)
USE_INPUT_SC    # allow the use of the input side chain conformation   ( see below for more detailed description of commands)
start
<PDBNUM>[<ICODE>] <CHAIN>  <COMMANDS> 	#<PDBNUM>[<ICODE>] corresponds to columns 22-26
40A Q ALLAA   # Residue 40, insertion code A, on chain Q, use any residue type

so I need a script that can take input pdb + text file specifying certain res, output the desired resfile
will make and call resfile.py
------------------------------------------------

rel = pyrosetta.rosetta.protocols.relax.FastRelax()
tf = pyrosetta.rosetta.core.pack.task.TaskFactory()
read = pyrosetta.rosetta.core.pack.task.operation.ReadResfile('2xbn.resfile')
tf.push_back(read)
rel.set_task_factory(tf)

sf = get_fa_scorefxn()
rel.set_scorefxn(sf)

mm = MoveMap()
mm.set_bb(True)
mm.set_chi(True)
rel.set_movemap(mm)

rel.apply(p)

#This works, and I'm curious to check if it is doing what I want, and to figure out
#how to add the harmonic coordinate constraints, ex1, extra chi 0, but for now I am
#gonna move on to trying with command line rosetta

echi = pyrosetta.rosetta.core.pack.task.operation.ExtraChiCutoff(0.0)
tf.push_back(echi)
ex1 = pyrosetta.rosetta.core.pack.task.operation.ExtraRotamersGeneric().ex1(True)
ex2 = pyrosetta.rosetta.core.pack.task.operation.ExtraRotamersGeneric().ex2(True)
tf.push_back(ex1)
tf.push_back(ex2)
rel.constrain_relax_to_start_coords(constrain_relax_to_start_coords=True)
coord_cst_stdev .5
------------------------------------------------
~/desktop/Rosetta/main/source/bin/score_jd2.macosclangrelease -in:file:s 2xbn_complex.pdb -ignore_unrecognized_res
time ~/desktop/Rosetta/main/source/bin/relax.default.macosclangrelease -s 2xbn_complex.pdb -resfile 2xbn.resfile -extra_res_fa pmp.params -ex1 -ex2 -extrachi_cutoff 0 -nstruct 3 -in:file:fullatom -relax:fast -relax:respect_resfile -relax:constrain_relax_to_start_coords -relax:coord_cst_stdev .5
------------------------------------------------
<ROSETTASCRIPTS> ~/desktop/Rosetta/main/source/bin/rosetta_scripts.default.macosclangrelease -l pdblist.txt -extra_res_fa pmp.params -parser:protocol iam.xml -parser:view -out:file:score_only iam-score.sc
    <SCOREFXNS>
			<ScoreFunction name="sf" weights="ref2015">
			</ScoreFunction>
    </SCOREFXNS>
    <RESIDUE_SELECTORS>
    </RESIDUE_SELECTORS>
    <TASKOPERATIONS>
    </TASKOPERATIONS>
    <FILTERS>
    </FILTERS>
    <MOVERS>
			<InterfaceAnalyzerMover name="iam" scorefxn="sf" packstat="True" interface_sc="True" />
    </MOVERS>
    <PROTOCOLS>
			<Add mover_name="iam"/>
    </PROTOCOLS>
    <OUTPUT />
</ROSETTASCRIPTS>
------------------------------------------------
Natural sequences of these binding sites were obtained using the protein family
 alignment from Pfam and filtered to remove all redundant sequences.


 Once the
multiple alignment is de®ned, the pro®le is constructed by counting the numbers of each amino
acid at each position along the multiple alignment.
These counts are transformed into probabilities by
normalizing the counts by the total number of
amino acids and gaps observed at that position.
These empirical probabilities re¯ect the likelihood
of observing any amino acid k at position i. Since
the counts are based on a ®nite set of sequences it
can happen that not all 20 amino acids are
observed at each position. Therefore, pseudo
counts are introduced so that no amino acid has a
zero probability to occur at position i. For more
information on pro®le generating techniques, see
Gribskov & Veretnik.26

1. get the sequences
2. function to turn sequences into probability distributions
3. function to calculate js divergence for each position in 2 profiles
pps = 1-js
is it just for positions that are designable? or does it not matter since those
only differences, so doing for whole thing captures anyway

pseudo counts you can just add one to every event
need to add to this code, change lists to counts and start at 1
then string together into script that takes 2 alignment fastas and returns pps
for each position
then im gonna need a way to generate seq alignments from list of pdb files
output by filter script. at that point i have
everything but the actual strc and native sequences to run
score->filter->subset_alignments->pps_subset/natural_binding_pos

actual strc
native sequences
position of binding site residues in native alignment
position of bionding site residues in designs alignment
'''
'''
------------------------------------------------

import Bio as bio
from Bio.Align.Applications import MafftCommandline
>>> from Bio.Align.Applications import MafftCommandline
>>> mafft_exe = "/opt/local/mafft"
>>> in_file = "../Doc/examples/opuntia.fasta"
>>> mafft_cline = MafftCommandline(mafft_exe, input=in_file)
>>> print(mafft_cline)
/opt/local/mafft ../Doc/examples/opuntia.fasta

If the mafft binary is on the path (typically the case on a Unix style operating system) then you don't need to supply the executable location:

>>> from Bio.Align.Applications import MafftCommandline
>>> in_file = "../Doc/examples/opuntia.fasta"
>>> mafft_cline = MafftCommandline(input=in_file)
>>> print(mafft_cline)
mafft ../Doc/examples/opuntia.fasta

You would typically run the command line with mafft_cline() or via the Python subprocess module, as described in the Biopython tutorial.

Note that MAFFT will write the alignment to stdout, which you may want to save to a file and then parse, e.g.:

stdout, stderr = mafft_cline()
with open("aligned.fasta", "w") as handle:
    handle.write(stdout)
from Bio import AlignIO
align = AlignIO.read("aligned.fasta", "fasta")

from Bio import SeqIO as seqio
for record in seqio.parse('2xbn_complex.pdb','pdb-atom'):
  s=record.seq
